trigger: none

variables:
  - group: variable-group-taller
  - name: environmentPath
  # AKS Cluster details
  - name: aksResourceGroup
    value: 'dev-resource-group'
  - name: aksClusterName
    value: 'dev-aks-cluster'
  - name: kubernetesNamespace
    value: 'ecommerce'
  - name: zapInstallDir
    value: '$(Agent.ToolsDirectory)/zap'
  - name: nginxServiceName
    value: 'nginx-proxy'

stages:
- stage: Deploy
  displayName: 'Deploy to AKS'
  jobs:
  - deployment: DeployToAKS
    displayName: 'Deploy Microservices to AKS'
    environment: 'development'
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self
          - task: AzureCLI@2
            displayName: 'Get AKS credentials'
            inputs:
              azureSubscription: $(AZURE_ACCOUNT)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                az aks get-credentials --resource-group $(aksResourceGroup) --name $(aksClusterName) --overwrite-existing
          - task: Kubernetes@1
            displayName: 'Create Namespace'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(AZURE_ACCOUNT)
              azureResourceGroup: $(aksResourceGroup)
              kubernetesCluster: $(aksClusterName)
              command: 'apply'
              arguments: '-f k8s-aks/namespace.yaml'
              workingDirectory: '$(System.DefaultWorkingDirectory)'

          - task: Kubernetes@1
            displayName: 'Deploy Zipkin'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(AZURE_ACCOUNT)
              azureResourceGroup: $(aksResourceGroup)
              kubernetesCluster: $(aksClusterName)
              command: 'apply'
              arguments: '-f k8s-aks/zipkin.yaml'
              workingDirectory: '$(System.DefaultWorkingDirectory)'

          - task: Kubernetes@1
            displayName: 'Deploy Cloud Config Service'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(AZURE_ACCOUNT)
              azureResourceGroup: $(aksResourceGroup)
              kubernetesCluster: $(aksClusterName)
              command: 'apply'
              arguments: '-f k8s-aks/cloud-config.yaml'
              workingDirectory: '$(System.DefaultWorkingDirectory)'
              
          - task: Kubernetes@1
            displayName: 'Deploy Service Discovery'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(AZURE_ACCOUNT)
              azureResourceGroup: $(aksResourceGroup)
              kubernetesCluster: $(aksClusterName)
              command: 'apply'
              arguments: '-f k8s-aks/service-discovery.yaml'
              workingDirectory: '$(System.DefaultWorkingDirectory)'

          - task: Kubernetes@1
            displayName: 'Deploy API Gateway'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(AZURE_ACCOUNT)
              azureResourceGroup: $(aksResourceGroup)
              kubernetesCluster: $(aksClusterName)
              command: 'apply'
              arguments: '-f k8s-aks/api-gateway.yaml'
              workingDirectory: '$(System.DefaultWorkingDirectory)'

          - task: Kubernetes@1
            displayName: 'Deploy User Service'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(AZURE_ACCOUNT)
              azureResourceGroup: $(aksResourceGroup)
              kubernetesCluster: $(aksClusterName)
              command: 'apply'
              arguments: '-f k8s-aks/user-service.yaml'
              workingDirectory: '$(System.DefaultWorkingDirectory)'
              
          - task: Kubernetes@1
            displayName: 'Deploy Product Service'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(AZURE_ACCOUNT)
              azureResourceGroup: $(aksResourceGroup)
              kubernetesCluster: $(aksClusterName)
              command: 'apply'
              arguments: '-f k8s-aks/product-service.yaml'
              workingDirectory: '$(System.DefaultWorkingDirectory)'
              
          - task: Kubernetes@1
            displayName: 'Deploy Order Service'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(AZURE_ACCOUNT)
              azureResourceGroup: $(aksResourceGroup)
              kubernetesCluster: $(aksClusterName)
              command: 'apply'
              arguments: '-f k8s-aks/order-service.yaml'
              workingDirectory: '$(System.DefaultWorkingDirectory)'
              
          - task: Kubernetes@1
            displayName: 'Deploy Payment Service'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(AZURE_ACCOUNT)
              azureResourceGroup: $(aksResourceGroup)
              kubernetesCluster: $(aksClusterName)
              command: 'apply'
              arguments: '-f k8s-aks/payment-service.yaml'
              workingDirectory: '$(System.DefaultWorkingDirectory)'
              
          - task: Kubernetes@1
            displayName: 'Deploy Favourite Service'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(AZURE_ACCOUNT)
              azureResourceGroup: $(aksResourceGroup)
              kubernetesCluster: $(aksClusterName)
              command: 'apply'
              arguments: '-f k8s-aks/favourite-service.yaml'
              workingDirectory: '$(System.DefaultWorkingDirectory)'
              
          - task: Kubernetes@1
            displayName: 'Deploy Shipping Service'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(AZURE_ACCOUNT)
              azureResourceGroup: $(aksResourceGroup)
              kubernetesCluster: $(aksClusterName)
              command: 'apply'
              arguments: '-f k8s-aks/shipping-service.yaml'
              workingDirectory: '$(System.DefaultWorkingDirectory)'
              
          - task: Kubernetes@1
            displayName: 'Deploy Proxy Client'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(AZURE_ACCOUNT)
              azureResourceGroup: $(aksResourceGroup)
              kubernetesCluster: $(aksClusterName)
              command: 'apply'
              arguments: '-f k8s-aks/proxy-client.yaml'
              workingDirectory: '$(System.DefaultWorkingDirectory)'
              
          - task: Kubernetes@1
            displayName: 'Deploy Nginx'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(AZURE_ACCOUNT)
              azureResourceGroup: $(aksResourceGroup)
              kubernetesCluster: $(aksClusterName)
              command: 'apply'
              arguments: '-f k8s-aks/nginx.yaml'
              workingDirectory: '$(System.DefaultWorkingDirectory)'
              
          - task: Kubernetes@1
            displayName: 'Verify Deployment Status'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(AZURE_ACCOUNT)
              azureResourceGroup: $(aksResourceGroup)
              kubernetesCluster: $(aksClusterName)
              command: 'get'
              arguments: 'pods -n $(kubernetesNamespace)'
              workingDirectory: '$(System.DefaultWorkingDirectory)'
              
          - task: Kubernetes@1
            displayName: 'Get Services Status'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(AZURE_ACCOUNT)
              azureResourceGroup: $(aksResourceGroup)
              kubernetesCluster: $(aksClusterName)
              command: 'get'
              arguments: 'services -n $(kubernetesNamespace)'
              workingDirectory: '$(System.DefaultWorkingDirectory)'
- stage: GetNginxIP
  displayName: 'Obtener IP pública de nginx-proxy'
  jobs:
    - job: CaptureNginxIP
      displayName: 'Capturar IP del servicio nginx'
      pool:
        vmImage: 'ubuntu-latest'
      steps:
        - task: AzureCLI@2
          displayName: 'Login to Azure y obtener credenciales del clúster'
          inputs:
            azureSubscription: '$(AZURE_ACCOUNT)'
            scriptType: bash
            scriptLocation: inlineScript
            inlineScript: |
              az aks get-credentials --resource-group $(aksResourceGroup) --name $(aksClusterName) --overwrite-existing

        - script: |
            echo "Esperando IP pública del servicio nginx..."
            for i in {1..10}; do
              IP=$(kubectl get svc $(nginxServiceName) -n $(kubernetesNamespace) -o jsonpath="{.status.loadBalancer.ingress[0].ip}")
              if [[ -n "$IP" ]]; then
                echo "IP pública obtenida: $IP"
                echo "##vso[task.setvariable variable=NGINX_PUBLIC_IP;isOutput=true]$IP"
                break
              else
                echo "IP aún no disponible, reintentando en 10 segundos..."
                sleep 10
              fi
            done
          displayName: 'Capturar IP pública del nginx'
          name: CaptureIP
          
- stage: ZAPScan
  displayName: 'Escaneo de Seguridad con OWASP ZAP'
  dependsOn: GetNginxIP
  condition: succeeded()
  jobs:
    - job: RunZapScan
      displayName: 'Ejecutar OWASP ZAP contra múltiples endpoints'
      pool:
        vmImage: 'ubuntu-latest'
      variables:
        NGINX_IP: $[ dependencies.GetNginxIP.outputs['CaptureNginxIP.CaptureIP.NGINX_PUBLIC_IP'] ]
        # Define aquí los endpoints que quieres escanear
        ENDPOINTS: |
          /user-service/api/users
          /user-service/api/auth/login
          /user-service/api/health
          /product-service/api/products
          /order-service/api/orders
      steps:
        - task: AzureCLI@2
          displayName: 'Login to Azure y obtener credenciales del clúster'
          inputs:
            azureSubscription: '$(AZURE_ACCOUNT)'
            scriptType: bash
            scriptLocation: inlineScript
            inlineScript: |
              az aks get-credentials --resource-group $(aksResourceGroup) --name $(aksClusterName) --overwrite-existing
        
        - bash: |
            echo "Instalando OWASP ZAP..."
            sudo apt-get update
            sudo apt-get install -y snap
            sudo snap install zaproxy --classic
          displayName: 'Instalar OWASP ZAP'

        - bash: |
            echo "Preparando directorios y obteniendo IP..."
            mkdir -p owaspzap
            IP=$(kubectl get svc $(nginxServiceName) -n $(kubernetesNamespace) -o jsonpath="{.status.loadBalancer.ingress[0].ip}")
            echo "IP obtenida: $IP"
            
            # Crear archivo de endpoints
            cat > owaspzap/endpoints.txt << EOF
            $(ENDPOINTS)
            EOF
            
            # Filtrar líneas vacías
            grep -v '^$' owaspzap/endpoints.txt > owaspzap/clean_endpoints.txt
            
            echo "Endpoints a escanear:"
            cat owaspzap/clean_endpoints.txt
            
            # Iniciar ZAP en modo daemon
            echo "Iniciando ZAP daemon..."
            zaproxy -daemon -host 0.0.0.0 -port 8080 &
            ZAP_PID=$!
            
            # Esperar a que ZAP esté listo
            echo "Esperando a que ZAP esté listo..."
            sleep 30
            
            # Verificar que ZAP está ejecutándose
            if ! curl -s http://localhost:8080 > /dev/null; then
                echo "Error: ZAP no está ejecutándose correctamente"
                exit 1
            fi
            
            echo "ZAP daemon iniciado correctamente"
            echo $ZAP_PID > owaspzap/zap.pid
          displayName: 'Preparar escaneo y iniciar ZAP daemon'

        - bash: |
            IP=$(kubectl get svc $(nginxServiceName) -n $(kubernetesNamespace) -o jsonpath="{.status.loadBalancer.ingress[0].ip}")
            
            echo "Ejecutando escaneos ZAP contra múltiples endpoints..."
            
            # Función para realizar spider y scan activo
            scan_endpoint() {
                local endpoint=$1
                local url="http://${IP}${endpoint}"
                echo "Escaneando: $url"
                
                # Spider del endpoint
                echo "Ejecutando spider en $url"
                curl -s "http://localhost:8080/JSON/spider/action/scan/?url=${url}" > /dev/null
                
                # Esperar a que termine el spider
                while [ $(curl -s "http://localhost:8080/JSON/spider/view/status/" | grep -o '"status":"[0-9]*"' | cut -d'"' -f4) -lt 100 ]; do
                    sleep 2
                done
                
                # Escaneo activo
                echo "Ejecutando escaneo activo en $url"
                curl -s "http://localhost:8080/JSON/ascan/action/scan/?url=${url}" > /dev/null
                
                # Esperar a que termine el escaneo activo
                while [ $(curl -s "http://localhost:8080/JSON/ascan/view/status/" | grep -o '"status":"[0-9]*"' | cut -d'"' -f4) -lt 100 ]; do
                    sleep 5
                done
            }
            
            # Escanear cada endpoint
            while IFS= read -r endpoint; do
                if [ ! -z "$endpoint" ] && [ "$endpoint" != "" ]; then
                    scan_endpoint "$endpoint"
                fi
            done < owaspzap/clean_endpoints.txt
            
            echo "Todos los escaneos completados"
            
          displayName: 'Ejecutar escaneos ZAP en múltiples endpoints'

        - bash: |
            echo "Generando reporte consolidado..."
            
            # Generar reporte JSON consolidado
            curl -s "http://localhost:8080/JSON/core/view/alerts/" > owaspzap/report.json
            
            # Generar reporte HTML consolidado
            curl -s "http://localhost:8080/OTHER/core/other/htmlreport/" > owaspzap/report.html
            
            # Generar reporte XML
            curl -s "http://localhost:8080/OTHER/core/other/xmlreport/" > owaspzap/report.xml
            
            echo "Reportes generados exitosamente"
            
            # Mostrar resumen de vulnerabilidades encontradas
            echo "=== RESUMEN DE VULNERABILIDADES ==="
            if [ -f owaspzap/report.json ]; then
                python3 -c "
            import json
            import sys
            try:
                with open('owaspzap/report.json', 'r') as f:
                    data = json.load(f)
                alerts = data.get('alerts', [])
                print(f'Total de vulnerabilidades encontradas: {len(alerts)}')
                
                # Contar por nivel de riesgo
                risk_counts = {}
                for alert in alerts:
                    risk = alert.get('risk', 'Unknown')
                    risk_counts[risk] = risk_counts.get(risk, 0) + 1
                
                for risk, count in risk_counts.items():
                    print(f'{risk}: {count}')
                    
            except Exception as e:
                print(f'Error procesando reporte: {e}')
            "
                        fi
                        
                        # Detener ZAP daemon
                        if [ -f owaspzap/zap.pid ]; then
                            ZAP_PID=$(cat owaspzap/zap.pid)
                            kill $ZAP_PID || true
                        fi
                        
                    displayName: 'Generar reportes consolidados'

                    - bash: |
                        # Instalar handlebars para generar formato NUnit
                        sudo npm install -g handlebars-cmd
                        
                        # Crear plantilla NUnit mejorada
                        cat <<'EOF' > owaspzap/nunit-template.hbs
            <?xml version="1.0" encoding="utf-8"?>
            <test-results name="OWASP ZAP Security Scan" total="{{alerts.length}}" failures="{{alerts.length}}" not-run="0" date="{{@generated}}" time="{{@generated}}">
              <environment />
              <culture-info />
              <test-suite name="OWASP ZAP Security Tests" executed="True" result="{{#if alerts.length}}Failure{{else}}Success{{/if}}" success="{{#unless alerts.length}}True{{else}}False{{/unless}}" time="0" asserts="{{alerts.length}}">
                <results>
                  {{#each alerts}}
                  <test-case name="{{alert}} - {{url}}" executed="True" result="Failure" success="False" time="0" asserts="1">
                    <failure>
                      <message><![CDATA[
            Security Issue: {{alert}}
            Risk Level: {{risk}}
            Confidence: {{confidence}}
            URL: {{url}}
            Description: {{desc}}
                      ]]></message>
                      <stack-trace><![CDATA[
            Solution: {{solution}}
            Reference: {{reference}}
            Other Info: {{other}}

            Instances:
            {{#each instances}}
            - URL: {{uri}}
            - Method: {{method}}
            {{#if evidence}}- Evidence: {{evidence}}{{/if}}
            {{#if attack}}- Attack: {{attack}}{{/if}}
            {{#if param}}- Parameter: {{param}}{{/if}}
            {{/each}}
                      ]]></stack-trace>
                    </failure>
                  </test-case>
                  {{/each}}
                </results>
              </test-suite>
            </test-results>
            EOF
                        
                    displayName: 'Crear plantilla NUnit para reporte consolidado'

                    - bash: |
                        echo "Generando archivo de resultados NUnit..."
                        if [ -f owaspzap/report.json ]; then
                            handlebars owaspzap/report.json < owaspzap/nunit-template.hbs > owaspzap/test-results.xml
                            echo "Archivo NUnit generado exitosamente"
                        else
                            echo "Error: No se encontró el archivo de reporte JSON"
                            exit 1
                        fi
                    displayName: 'Generar archivo de resultados NUnit'

                    - task: PublishTestResults@2
                      displayName: 'Publicar resultados del escaneo consolidado'
                      inputs:
                        testResultsFormat: 'NUnit'
                        testResultsFiles: 'owaspzap/test-results.xml'
                        failTaskOnFailedTests: false
                        testRunTitle: 'OWASP ZAP Security Scan Results'

                    - task: PublishBuildArtifacts@1
                      displayName: 'Publicar reportes como artefactos'
                      inputs:
                        pathToPublish: 'owaspzap'
                        artifactName: 'owasp-zap-reports'
                        publishLocation: 'Container'
                      condition: always()

                    - bash: |
                        echo "=== RESUMEN FINAL DEL ESCANEO ==="
                        echo "Endpoints escaneados:"
                        cat owaspzap/clean_endpoints.txt
                        echo ""
                        echo "Archivos generados:"
                        ls -la owaspzap/
                        echo ""
                        if [ -f owaspzap/report.json ]; then
                            echo "Reporte JSON: ✓"
                        else
                            echo "Reporte JSON: ✗"
                        fi
                        if [ -f owaspzap/report.html ]; then
                            echo "Reporte HTML: ✓"
                        else
                            echo "Reporte HTML: ✗"
                        fi
                        if [ -f owaspzap/test-results.xml ]; then
                            echo "Reporte NUnit: ✓"
                        else
                            echo "Reporte NUnit: ✗"
                        fi
                    displayName: 'Mostrar resumen final'
                    condition: always()