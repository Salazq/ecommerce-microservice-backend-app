trigger:
  branches:
    include:
      - master
  paths:
    include:
      - service-discovery/**
      - cloud-config/**
      - api-gateway/**
      - proxy-client/**
      - order-service/**
      - product-service/**
      - user-service/**
      - shipping-service/**
      - payment-service/**
      - favourite-service/**
      - nginx/**

variables:
  - group: variable-group-taller
  - name: tag
    value: prod
  - name: aksResourceGroup
    value: 'prod-resource-group'
  - name: aksClusterName
    value: 'prod-aks-cluster'
  - name: kubernetesNamespace
    value: 'ecommerce'
  - name: dockerHubUsername
    value: 'salazq'
  - name: vmImageName
    value: 'ubuntu-latest'
  - name: nginxServiceName
    value: 'nginx-proxy'

stages:


- stage: CheckNamespaceAndRedeployModifiedServices
  displayName: 'Check Namespace and Redeploy Modified Services'
  jobs:
    - job: CheckAndRedeploy
      displayName: 'Verificar Namespace y Reemplazar Servicios Modificados'
      pool:
        vmImage: $(vmImageName)
      steps:
        - checkout: self
          fetchDepth: 0

        - task: AzureCLI@2
          name: checkNamespace
          displayName: 'Check if Namespace Exists'
          inputs:
            azureSubscription: $(AZURE_ACCOUNT)
            scriptType: bash
            scriptLocation: inlineScript
            inlineScript: |
              az aks get-credentials --resource-group $(aksResourceGroup) --name $(aksClusterName) --overwrite-existing
              if kubectl get namespace $(kubernetesNamespace) 2>/dev/null; then
                echo "âœ… Namespace $(kubernetesNamespace) existe"
                echo "##vso[task.setvariable variable=namespaceExists;isOutput=true]true"
              else
                echo "âŒ Namespace $(kubernetesNamespace) no existe"
                echo "##vso[task.setvariable variable=namespaceExists;isOutput=true]false"
              fi

        - script: |
            echo "ðŸ” Detectando carpetas modificadas..."
            
            # Obtener archivos modificados
            git diff --name-only HEAD~1 HEAD > changed_files.txt
            echo "ðŸ“„ Archivos modificados:"
            cat changed_files.txt
            
            # Extraer carpetas de primer nivel
            grep '/' changed_files.txt | cut -d/ -f1 | sort -u > changed_dirs_raw.txt || true
            echo "ðŸ“ Carpetas detectadas:"
            cat changed_dirs_raw.txt || echo "(ninguna)"

            # Lista de carpetas vÃ¡lidas
            allowed_dirs=(
              "service-discovery"
              "cloud-config"
              "api-gateway"
              "proxy-client"
              "order-service"
              "product-service"
              "user-service"
              "shipping-service"
              "payment-service"
              "favourite-service"
              "nginx"
            )

            # Filtrar solo las carpetas permitidas
            > changed_dirs.txt
            if [ -s changed_dirs_raw.txt ]; then
              while IFS= read -r dir; do
                for allowed in "${allowed_dirs[@]}"; do
                  if [[ "$dir" == "$allowed" ]]; then
                    echo "$dir" >> changed_dirs.txt
                    break
                  fi
                done
              done < changed_dirs_raw.txt
            fi

            echo "ðŸ“¦ Servicios modificados vÃ¡lidos:"
            if [ -s changed_dirs.txt ]; then
              cat changed_dirs.txt
            else
              echo "(ninguno)"
            fi

            # Verificar si hay servicios para reemplazar
            servicios_reemplazados=false
            if [ -s changed_dirs.txt ]; then
              while IFS= read -r dir; do
                echo "âž¡ Procesando $dir..."
                if [[ -f "$dir/Dockerfile" && -f "k8s-$(tag)/$dir.yaml" ]]; then
                  echo "ðŸ”„ Borrando deployment $dir..."
                  kubectl delete -f k8s-$(tag)/$dir.yaml -n $(kubernetesNamespace) --ignore-not-found=true
                  echo "ðŸš€ Aplicando nuevo deployment..."
                  kubectl apply -f k8s-$(tag)/$dir.yaml -n $(kubernetesNamespace)
                  servicios_reemplazados=true
                  echo "âœ… Servicio $dir reemplazado exitosamente"
                else
                  echo "âš ï¸ Saltando $dir (no tiene Dockerfile o archivo YAML correspondiente)"
                fi
              done < changed_dirs.txt
            fi

            # Establecer variables de salida
            if [[ "$servicios_reemplazados" == "true" ]]; then
              echo "âœ… Servicios reemplazados exitosamente, omitiendo etapas siguientes..."
              echo "##vso[task.setvariable variable=skipNextStages;isOutput=true]true"
              echo "##vso[task.setvariable variable=servicesRedeployed;isOutput=true]true"
            else
              echo "â„¹ï¸ No se reemplazÃ³ ningÃºn servicio vÃ¡lido."
              echo "##vso[task.setvariable variable=skipNextStages;isOutput=true]false"
              echo "##vso[task.setvariable variable=servicesRedeployed;isOutput=true]false"
            fi
          displayName: 'Reemplazar Microservicios Modificados'
          name: replaceServices
          condition: eq(variables['checkNamespace.namespaceExists'], 'true')

        - script: |
            echo "â„¹ï¸ Namespace no existe, se ejecutarÃ¡ el despliegue completo en los siguientes stages"
            echo "##vso[task.setvariable variable=skipNextStages;isOutput=true]false"
            echo "##vso[task.setvariable variable=servicesRedeployed;isOutput=true]false"
          displayName: 'Configurar para Despliegue Completo'
          name: configureFullDeploy
          condition: eq(variables['checkNamespace.namespaceExists'], 'false')




- stage: DeployGrafanaMonitoring
  displayName: 'Deploy Grafana Monitoring Stack'
  dependsOn: CheckNamespaceAndRedeployModifiedServices
  condition: and(succeeded(), eq(dependencies.CheckNamespaceAndRedeployModifiedServices.outputs['CheckAndRedeploy.replaceServices.skipNextStages'], 'false'), eq(dependencies.CheckNamespaceAndRedeployModifiedServices.outputs['CheckAndRedeploy.configureFullDeploy.skipNextStages'], 'false'))
  jobs:
    - job: RunGrafanaMonitoring
      displayName: 'Deploy .grafana script to AKS'
      pool:
        vmImage: 'ubuntu-latest'
      steps:
        - task: AzureCLI@2
          displayName: 'Login to AKS Cluster'
          inputs:
            azureSubscription: $(AZURE_ACCOUNT)  # Cambia esto por tu nombre de servicio (Service Connection)
            scriptType: bash
            scriptLocation: inlineScript
            inlineScript: |
              az aks get-credentials --resource-group $(aksResourceGroup) --name $(aksClusterName) --overwrite-existing
          env:
            AZURE_DEVOPS_EXT_AZURE_RM_SERVICE_PRINCIPAL_CERTIFICATE: $(AZURE_DEVOPS_EXT_AZURE_RM_SERVICE_PRINCIPAL_CERTIFICATE)

        - task: DownloadSecureFile@1
          name: grafanaDeployScriptFile
          displayName: 'Download .grafana script'
          inputs:
            secureFile: 'grafana3'

        - script: |
            chmod +x $(grafanaDeployScriptFile.secureFilePath)
          displayName: 'Dar permisos de ejecuciÃ³n al script'

        - task: Bash@3
          displayName: 'Ejecutar script .grafana'
          inputs:
            filePath: $(grafanaDeployScriptFile.secureFilePath)


- stage: Deploy
  displayName: 'Deploy to AKS'
  dependsOn: DeployGrafanaMonitoring
  condition: and(succeeded(), eq(dependencies.CheckNamespaceAndRedeployModifiedServices.outputs['CheckAndRedeploy.replaceServices.skipNextStages'], 'false'), eq(dependencies.CheckNamespaceAndRedeployModifiedServices.outputs['CheckAndRedeploy.configureFullDeploy.skipNextStages'], 'false'))
  jobs:
  - deployment: DeployToAKS
    displayName: 'Deploy Microservices to AKS'
    environment: 'development'
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self
          - task: AzureCLI@2
            displayName: 'Get AKS credentials'
            inputs:
              azureSubscription: $(AZURE_ACCOUNT)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                az aks get-credentials --resource-group $(aksResourceGroup) --name $(aksClusterName) --overwrite-existing
          - task: Kubernetes@1
            displayName: 'Create Namespace'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(AZURE_ACCOUNT)
              azureResourceGroup: $(aksResourceGroup)
              kubernetesCluster: $(aksClusterName)
              command: 'apply'
              arguments: '-f k8s-$(tag)/namespace.yaml'
              workingDirectory: '$(System.DefaultWorkingDirectory)'

          - task: Kubernetes@1
            displayName: 'Deploy Zipkin'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(AZURE_ACCOUNT)
              azureResourceGroup: $(aksResourceGroup)
              kubernetesCluster: $(aksClusterName)
              command: 'apply'
              arguments: '-f k8s-$(tag)/zipkin.yaml'
              workingDirectory: '$(System.DefaultWorkingDirectory)'

          - task: Kubernetes@1
            displayName: 'Deploy Cloud Config Service'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(AZURE_ACCOUNT)
              azureResourceGroup: $(aksResourceGroup)
              kubernetesCluster: $(aksClusterName)
              command: 'apply'
              arguments: '-f k8s-$(tag)/cloud-config.yaml'
              workingDirectory: '$(System.DefaultWorkingDirectory)'
              
          - task: Kubernetes@1
            displayName: 'Deploy Service Discovery'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(AZURE_ACCOUNT)
              azureResourceGroup: $(aksResourceGroup)
              kubernetesCluster: $(aksClusterName)
              command: 'apply'
              arguments: '-f k8s-$(tag)/service-discovery.yaml'
              workingDirectory: '$(System.DefaultWorkingDirectory)'

          - task: Kubernetes@1
            displayName: 'Deploy API Gateway'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(AZURE_ACCOUNT)
              azureResourceGroup: $(aksResourceGroup)
              kubernetesCluster: $(aksClusterName)
              command: 'apply'
              arguments: '-f k8s-$(tag)/api-gateway.yaml'
              workingDirectory: '$(System.DefaultWorkingDirectory)'

          - task: Kubernetes@1
            displayName: 'Deploy User Service'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(AZURE_ACCOUNT)
              azureResourceGroup: $(aksResourceGroup)
              kubernetesCluster: $(aksClusterName)
              command: 'apply'
              arguments: '-f k8s-$(tag)/user-service.yaml'
              workingDirectory: '$(System.DefaultWorkingDirectory)'
              
          - task: Kubernetes@1
            displayName: 'Deploy Product Service'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(AZURE_ACCOUNT)
              azureResourceGroup: $(aksResourceGroup)
              kubernetesCluster: $(aksClusterName)
              command: 'apply'
              arguments: '-f k8s-$(tag)/product-service.yaml'
              workingDirectory: '$(System.DefaultWorkingDirectory)'
              
          - task: Kubernetes@1
            displayName: 'Deploy Order Service'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(AZURE_ACCOUNT)
              azureResourceGroup: $(aksResourceGroup)
              kubernetesCluster: $(aksClusterName)
              command: 'apply'
              arguments: '-f k8s-$(tag)/order-service.yaml'
              workingDirectory: '$(System.DefaultWorkingDirectory)'
              
          - task: Kubernetes@1
            displayName: 'Deploy Payment Service'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(AZURE_ACCOUNT)
              azureResourceGroup: $(aksResourceGroup)
              kubernetesCluster: $(aksClusterName)
              command: 'apply'
              arguments: '-f k8s-$(tag)/payment-service.yaml'
              workingDirectory: '$(System.DefaultWorkingDirectory)'
              
          - task: Kubernetes@1
            displayName: 'Deploy Favourite Service'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(AZURE_ACCOUNT)
              azureResourceGroup: $(aksResourceGroup)
              kubernetesCluster: $(aksClusterName)
              command: 'apply'
              arguments: '-f k8s-$(tag)/favourite-service.yaml'
              workingDirectory: '$(System.DefaultWorkingDirectory)'
              
          - task: Kubernetes@1
            displayName: 'Deploy Shipping Service'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(AZURE_ACCOUNT)
              azureResourceGroup: $(aksResourceGroup)
              kubernetesCluster: $(aksClusterName)
              command: 'apply'
              arguments: '-f k8s-$(tag)/shipping-service.yaml'
              workingDirectory: '$(System.DefaultWorkingDirectory)'
              
          - task: Kubernetes@1
            displayName: 'Deploy Proxy Client'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(AZURE_ACCOUNT)
              azureResourceGroup: $(aksResourceGroup)
              kubernetesCluster: $(aksClusterName)
              command: 'apply'
              arguments: '-f k8s-$(tag)/proxy-client.yaml'
              workingDirectory: '$(System.DefaultWorkingDirectory)'
              
          - task: Kubernetes@1
            displayName: 'Deploy Nginx'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(AZURE_ACCOUNT)
              azureResourceGroup: $(aksResourceGroup)
              kubernetesCluster: $(aksClusterName)
              command: 'apply'
              arguments: '-f k8s-$(tag)/nginx.yaml'
              workingDirectory: '$(System.DefaultWorkingDirectory)'
              
          - task: Kubernetes@1
            displayName: 'Verify Deployment Status'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(AZURE_ACCOUNT)
              azureResourceGroup: $(aksResourceGroup)
              kubernetesCluster: $(aksClusterName)
              command: 'get'
              arguments: 'pods -n $(kubernetesNamespace)'
              workingDirectory: '$(System.DefaultWorkingDirectory)'
              
          - task: Kubernetes@1
            displayName: 'Get Services Status'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(AZURE_ACCOUNT)
              azureResourceGroup: $(aksResourceGroup)
              kubernetesCluster: $(aksClusterName)
              command: 'get'
              arguments: 'services -n $(kubernetesNamespace)'
              workingDirectory: '$(System.DefaultWorkingDirectory)'

- stage: SemanticRelease
  displayName: 'Semantic Release & Versioning'
  dependsOn: Deploy
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master'))
  jobs:
  - job: Release
    displayName: 'Generate Semantic Release'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - checkout: self
      persistCredentials: true
      fetchDepth: 0
    
    - task: NodeTool@0
      displayName: 'Install Node.js 18.x'
      inputs:
        versionSpec: '18.x'
    
    - script: |
        echo "ðŸ“¦ Installing semantic-release dependencies..."
        npm ci
      displayName: 'Install Dependencies'
    
    - script: |
        echo "ðŸ” Running semantic-release dry-run..."
        npx semantic-release --dry-run
      displayName: 'Semantic Release Dry Run'
      env:
        GITHUB_TOKEN: $(GITHUB_TOKEN)
    
    - script: |
        echo "ðŸš€ Running semantic-release..."
        npx semantic-release
      displayName: 'Semantic Release'
      env:
        GITHUB_TOKEN: $(GITHUB_TOKEN)
        GIT_AUTHOR_NAME: Azure DevOps
        GIT_AUTHOR_EMAIL: azuredevops@company.com
        GIT_COMMITTER_NAME: Azure DevOps
        GIT_COMMITTER_EMAIL: azuredevops@company.com
    
    - task: PublishPipelineArtifact@1
      displayName: 'Publish Release Notes'
      inputs:
        targetPath: 'release-notes'
        artifact: 'release-notes'
      condition: always()
    
    - task: PublishPipelineArtifact@1
      displayName: 'Publish CHANGELOG'
      inputs:
        targetPath: 'CHANGELOG.md'
        artifact: 'changelog'
      condition: always()



