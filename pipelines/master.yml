trigger:
  branches:
    include:
      - master
  paths:
    include:
      - service-discovery/**
      - cloud-config/**
      - api-gateway/**
      - proxy-client/**
      - order-service/**
      - product-service/**
      - user-service/**
      - shipping-service/**
      - payment-service/**
      - favourite-service/**
      - nginx/**

variables:
  - group: variable-group-taller
  - name: tag
    value: prod
  - name: aksResourceGroup
    value: 'prod-resource-group'
  - name: aksClusterName
    value: 'prod-aks-cluster'
  - name: kubernetesNamespace
    value: 'ecommerce'
  - name: dockerHubUsername
    value: 'salazq'
  - name: vmImageName
    value: 'ubuntu-latest'
  - name: nginxServiceName
    value: 'nginx-proxy'

stages:

- stage: CheckNamespaceAndRedeployModifiedServices
  displayName: 'Check Namespace and Redeploy Modified Services'
  jobs:
    - job: CheckAndRedeploy
      displayName: 'Verificar Namespace y Reemplazar Servicios Modificados'
      pool:
        vmImage: $(vmImageName)
      steps:
        - checkout: self
          fetchDepth: 0

        - task: AzureCLI@2
          name: checkNamespace
          displayName: 'Check if Namespace Exists'
          inputs:
            azureSubscription: $(AZURE_ACCOUNT)
            scriptType: bash
            scriptLocation: inlineScript
            inlineScript: |
              az aks get-credentials --resource-group $(aksResourceGroup) --name $(aksClusterName) --overwrite-existing
              if kubectl get namespace $(kubernetesNamespace); then
                echo "##vso[task.setvariable variable=namespaceExists]true"
              else
                echo "##vso[task.setvariable variable=namespaceExists]false"
              fi

        - script: |
            echo "🔍 Detectando carpetas modificadas..."
            git diff --name-only HEAD^ HEAD > changed_files.txt
            grep '/' changed_files.txt | cut -d/ -f1 | sort -u > changed_dirs_raw.txt

            # Lista de carpetas válidas
            allowed_dirs=(
              service-discovery
              cloud-config
              api-gateway
              proxy-client
              order-service
              product-service
              user-service
              shipping-service
              payment-service
              favourite-service
              nginx
            )

            # Filtrar solo las carpetas permitidas
            grep -xF "${allowed_dirs[@]}" changed_dirs_raw.txt > changed_dirs.txt || true

            echo "📦 Servicios modificados válidos:"
            cat changed_dirs.txt || echo "(ninguno)"

            servicios_reemplazados=0
            while IFS= read -r dir; do
              echo "➡ Procesando $dir..."
              if [[ -f "$dir/Dockerfile" && -f "k8s-$(tag)/$dir.yaml" ]]; then
                echo "🔄 Borrando deployment $dir..."
                kubectl delete -f k8s-$(tag)/$dir.yaml -n $(kubernetesNamespace) --ignore-not-found
                echo "🚀 Aplicando nuevo deployment..."
                kubectl apply -f k8s-$(tag)/$dir.yaml -n $(kubernetesNamespace)
                servicios_reemplazados=1
              else
                echo "⚠️ Saltando $dir (no tiene Dockerfile o YAML)"
              fi
            done < changed_dirs.txt

            if [[ $servicios_reemplazados -eq 1 ]]; then
              echo "✅ Servicios reemplazados, omitiendo etapas siguientes..."
              echo "##vso[task.setvariable variable=skipNextStages]true"
            else
              echo "ℹ️ No se reemplazó ningún servicio."
            fi
          displayName: 'Reemplazar Microservicios Modificados'
          condition: eq(variables['namespaceExists'], 'true')




- stage: DeployGrafanaMonitoring
  displayName: 'Deploy Grafana Monitoring Stack'
  dependsOn: CheckNamespaceAndRedeployModifiedServices
  condition: and(succeeded(), ne(variables['skipNextStages'], 'true'))
  jobs:
    - job: RunGrafanaMonitoring
      displayName: 'Deploy .grafana script to AKS'
      pool:
        vmImage: 'ubuntu-latest'
      steps:
        - task: AzureCLI@2
          displayName: 'Login to AKS Cluster'
          inputs:
            azureSubscription: $(AZURE_ACCOUNT)  # Cambia esto por tu nombre de servicio (Service Connection)
            scriptType: bash
            scriptLocation: inlineScript
            inlineScript: |
              az aks get-credentials --resource-group $(aksResourceGroup) --name $(aksClusterName) --overwrite-existing
          env:
            AZURE_DEVOPS_EXT_AZURE_RM_SERVICE_PRINCIPAL_CERTIFICATE: $(AZURE_DEVOPS_EXT_AZURE_RM_SERVICE_PRINCIPAL_CERTIFICATE)

        - task: DownloadSecureFile@1
          name: grafanaDeployScriptFile
          displayName: 'Download .grafana script'
          inputs:
            secureFile: 'grafana3'

        - script: |
            chmod +x $(grafanaDeployScriptFile.secureFilePath)
          displayName: 'Dar permisos de ejecución al script'

        - task: Bash@3
          displayName: 'Ejecutar script .grafana'
          inputs:
            filePath: $(grafanaDeployScriptFile.secureFilePath)


- stage: Deploy
  displayName: 'Deploy to AKS'
  dependsOn: DeployGrafanaMonitoring
  condition: and(succeeded(), ne(variables['skipNextStages'], 'true'))
  jobs:
  - deployment: DeployToAKS
    displayName: 'Deploy Microservices to AKS'
    environment: 'development'
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self
          - task: AzureCLI@2
            displayName: 'Get AKS credentials'
            inputs:
              azureSubscription: $(AZURE_ACCOUNT)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                az aks get-credentials --resource-group $(aksResourceGroup) --name $(aksClusterName) --overwrite-existing
          - task: Kubernetes@1
            displayName: 'Create Namespace'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(AZURE_ACCOUNT)
              azureResourceGroup: $(aksResourceGroup)
              kubernetesCluster: $(aksClusterName)
              command: 'apply'
              arguments: '-f k8s-$(tag)/namespace.yaml'
              workingDirectory: '$(System.DefaultWorkingDirectory)'

          - task: Kubernetes@1
            displayName: 'Deploy Zipkin'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(AZURE_ACCOUNT)
              azureResourceGroup: $(aksResourceGroup)
              kubernetesCluster: $(aksClusterName)
              command: 'apply'
              arguments: '-f k8s-$(tag)/zipkin.yaml'
              workingDirectory: '$(System.DefaultWorkingDirectory)'

          - task: Kubernetes@1
            displayName: 'Deploy Cloud Config Service'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(AZURE_ACCOUNT)
              azureResourceGroup: $(aksResourceGroup)
              kubernetesCluster: $(aksClusterName)
              command: 'apply'
              arguments: '-f k8s-$(tag)/cloud-config.yaml'
              workingDirectory: '$(System.DefaultWorkingDirectory)'
              
          - task: Kubernetes@1
            displayName: 'Deploy Service Discovery'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(AZURE_ACCOUNT)
              azureResourceGroup: $(aksResourceGroup)
              kubernetesCluster: $(aksClusterName)
              command: 'apply'
              arguments: '-f k8s-$(tag)/service-discovery.yaml'
              workingDirectory: '$(System.DefaultWorkingDirectory)'

          - task: Kubernetes@1
            displayName: 'Deploy API Gateway'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(AZURE_ACCOUNT)
              azureResourceGroup: $(aksResourceGroup)
              kubernetesCluster: $(aksClusterName)
              command: 'apply'
              arguments: '-f k8s-$(tag)/api-gateway.yaml'
              workingDirectory: '$(System.DefaultWorkingDirectory)'

          - task: Kubernetes@1
            displayName: 'Deploy User Service'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(AZURE_ACCOUNT)
              azureResourceGroup: $(aksResourceGroup)
              kubernetesCluster: $(aksClusterName)
              command: 'apply'
              arguments: '-f k8s-$(tag)/user-service.yaml'
              workingDirectory: '$(System.DefaultWorkingDirectory)'
              
          - task: Kubernetes@1
            displayName: 'Deploy Product Service'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(AZURE_ACCOUNT)
              azureResourceGroup: $(aksResourceGroup)
              kubernetesCluster: $(aksClusterName)
              command: 'apply'
              arguments: '-f k8s-$(tag)/product-service.yaml'
              workingDirectory: '$(System.DefaultWorkingDirectory)'
              
          - task: Kubernetes@1
            displayName: 'Deploy Order Service'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(AZURE_ACCOUNT)
              azureResourceGroup: $(aksResourceGroup)
              kubernetesCluster: $(aksClusterName)
              command: 'apply'
              arguments: '-f k8s-$(tag)/order-service.yaml'
              workingDirectory: '$(System.DefaultWorkingDirectory)'
              
          - task: Kubernetes@1
            displayName: 'Deploy Payment Service'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(AZURE_ACCOUNT)
              azureResourceGroup: $(aksResourceGroup)
              kubernetesCluster: $(aksClusterName)
              command: 'apply'
              arguments: '-f k8s-$(tag)/payment-service.yaml'
              workingDirectory: '$(System.DefaultWorkingDirectory)'
              
          - task: Kubernetes@1
            displayName: 'Deploy Favourite Service'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(AZURE_ACCOUNT)
              azureResourceGroup: $(aksResourceGroup)
              kubernetesCluster: $(aksClusterName)
              command: 'apply'
              arguments: '-f k8s-$(tag)/favourite-service.yaml'
              workingDirectory: '$(System.DefaultWorkingDirectory)'
              
          - task: Kubernetes@1
            displayName: 'Deploy Shipping Service'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(AZURE_ACCOUNT)
              azureResourceGroup: $(aksResourceGroup)
              kubernetesCluster: $(aksClusterName)
              command: 'apply'
              arguments: '-f k8s-$(tag)/shipping-service.yaml'
              workingDirectory: '$(System.DefaultWorkingDirectory)'
              
          - task: Kubernetes@1
            displayName: 'Deploy Proxy Client'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(AZURE_ACCOUNT)
              azureResourceGroup: $(aksResourceGroup)
              kubernetesCluster: $(aksClusterName)
              command: 'apply'
              arguments: '-f k8s-$(tag)/proxy-client.yaml'
              workingDirectory: '$(System.DefaultWorkingDirectory)'
              
          - task: Kubernetes@1
            displayName: 'Deploy Nginx'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(AZURE_ACCOUNT)
              azureResourceGroup: $(aksResourceGroup)
              kubernetesCluster: $(aksClusterName)
              command: 'apply'
              arguments: '-f k8s-$(tag)/nginx.yaml'
              workingDirectory: '$(System.DefaultWorkingDirectory)'
              
          - task: Kubernetes@1
            displayName: 'Verify Deployment Status'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(AZURE_ACCOUNT)
              azureResourceGroup: $(aksResourceGroup)
              kubernetesCluster: $(aksClusterName)
              command: 'get'
              arguments: 'pods -n $(kubernetesNamespace)'
              workingDirectory: '$(System.DefaultWorkingDirectory)'
              
          - task: Kubernetes@1
            displayName: 'Get Services Status'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(AZURE_ACCOUNT)
              azureResourceGroup: $(aksResourceGroup)
              kubernetesCluster: $(aksClusterName)
              command: 'get'
              arguments: 'services -n $(kubernetesNamespace)'
              workingDirectory: '$(System.DefaultWorkingDirectory)'

- stage: SemanticRelease
  displayName: 'Semantic Release & Versioning'
  dependsOn: Deploy
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master'))
  jobs:
  - job: Release
    displayName: 'Generate Semantic Release'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - checkout: self
      persistCredentials: true
      fetchDepth: 0
    
    - task: NodeTool@0
      displayName: 'Install Node.js 18.x'
      inputs:
        versionSpec: '18.x'
    
    - script: |
        echo "📦 Installing semantic-release dependencies..."
        npm ci
      displayName: 'Install Dependencies'
    
    - script: |
        echo "🔍 Running semantic-release dry-run..."
        npx semantic-release --dry-run
      displayName: 'Semantic Release Dry Run'
      env:
        GITHUB_TOKEN: $(GITHUB_TOKEN)
    
    - script: |
        echo "🚀 Running semantic-release..."
        npx semantic-release
      displayName: 'Semantic Release'
      env:
        GITHUB_TOKEN: $(GITHUB_TOKEN)
        GIT_AUTHOR_NAME: Azure DevOps
        GIT_AUTHOR_EMAIL: azuredevops@company.com
        GIT_COMMITTER_NAME: Azure DevOps
        GIT_COMMITTER_EMAIL: azuredevops@company.com
    
    - task: PublishPipelineArtifact@1
      displayName: 'Publish Release Notes'
      inputs:
        targetPath: 'release-notes'
        artifact: 'release-notes'
      condition: always()
    
    - task: PublishPipelineArtifact@1
      displayName: 'Publish CHANGELOG'
      inputs:
        targetPath: 'CHANGELOG.md'
        artifact: 'changelog'
      condition: always()



